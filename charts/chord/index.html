<style>
  body,
  html {
    overflow: hidden;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .chart-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
  }
</style>

<div id="chart-wrapper" class="chart-wrapper"></div>

<script src="https://d3js.org/d3.v7.js"></script>
<script src="https://cafedata.io/charts/js/base-cafedata/v1.0.0.js"></script>

<script>
  let option;
  let chartDom;
  let chart;

  // TODO : set develop to false
  let develop = true;
  if (develop) {
    window.onload = () => {
      base_first_time({
        _col_rel: {
          labels: "category",
          values: "Mon",
        },
        _config: {
          chart: {
            fontSize: "16",
            fontWeight: "bold",
            palette:
              "#5470c6,#91cc75,#fac858,#ee6666,#73c0de,#3ba272,#fc845,#9a60b4,#ea7ccc,#a4243b,#00072d,#b6465f",
            background: "#ffffff",
            internalRadius: "30",
            externalRadius: "60",
            borderRadius: "20",
            borderWidth: "5",
            borderColor: "#ffffff",
            type: " false",
          },
        },
        // _data: data,
      });
      d3.csv("./data.csv", (newData) => {
        console.log(newData);
      });
    };
  }

  const init_handler = async () => {
    console.log("init_handler called");
    // create the svg area
    chart = d3
      .select("#chart-wrapper")
      .append("svg")
      .attr("width", 440)
      .attr("height", 440)
      .append("g")
      .attr("transform", "translate(220,220)");
    // create a matrix
    const matrix = [
      [0, 5871, 8916, 2868],
      [1951, 0, 2060, 6171],
      [8010, 16145, 0, 8045],
      [1013, 990, 940, 0],
    ];

    // 4 groups, so create a vector of 4 colors
    const colors = ["#440154ff", "#31668dff", "#37b578ff", "#fde725ff"];

    // give this matrix to d3.chord(): it will calculates all the info we need to draw arc and ribbon
    const res = d3.chord().padAngle(0.05).sortSubgroups(d3.descending)(matrix);

    // add the groups on the outer part of the circle
    chart
      .datum(res)
      .append("g")
      .selectAll("g")
      .data(function (d) {
        return d.groups;
      })
      .join("g")
      .append("path")
      .style("fill", (d, i) => colors[i])
      .style("stroke", "black")
      .attr("d", d3.arc().innerRadius(200).outerRadius(210));

    // Add the links between groups
    chart
      .datum(res)
      .append("g")
      .selectAll("path")
      .data((d) => d)
      .join("path")
      .attr("d", d3.ribbon().radius(200))
      .style("fill", (d) => colors[d.source.index]) // colors depend on the source group. Change to target otherwise.
      .style("stroke", "black");
  };

  const get_options = () => {
    option = {
      color: config.chart.palette.split(","),
      backgroundColor: config?.chart?.background,
      textStyle: {
        fontSize: `${config.chart?.fontSize}px`,
        fontWeight: config.chart?.fontWeight,
      },
      title: {
        show: config?.title?.show,
        text: config?.title?.text,
        backgroundColor: config?.title?.backgroundColor,
        textStyle: {
          color: config?.title?.color,
          fontSize: `${config?.title?.fontSize}px`,
          fontWeight: config?.title?.fontWeight,
        },
        subtext: config?.title?.subshow ? config?.title?.subtext : undefined,
        subtextStyle: {
          color: config?.title?.subcolor,
          fontSize: `${config?.title?.subfontSize}px`,
          fontWeight: config?.title?.subfontWeight,
        },
      },
      tooltip: {
        trigger: "axis",
        axisPointer: {
          type: "cross",
          label: {
            backgroundColor: "#6a7985",
          },
        },
      },
      legend: {
        show: config?.legend.show,
        orient: config?.legend.orient,
        top: config?.legend.vertical == "top" ? config?.legend.top : undefined,
        right:
          config?.legend.horizontal == "right"
            ? config?.legend.right
            : undefined,
        bottom:
          config?.legend.vertical == "bottom"
            ? config?.legend.bottom
            : undefined,
        left:
          config?.legend.horizontal == "left"
            ? config?.legend.left
            : config?.legend.horizontal == "center"
            ? "center"
            : undefined,
        textStyle: {
          color: config?.legend.color,
          fontSize: config?.legend.fontSize,
          fontWeight: config?.legend.fontWeight,
        },
      },
      toolbox: {
        feature: {
          // saveAsImage: {},
        },
      },
      xAxis: [
        {
          type: "category",
          boundaryGap: false,
          data: data[0].filter((item, index) => index > 0),
          position: config?.xAxis?.position,
          name: config?.xAxis?.showName && config?.xAxis?.name,
          nameLocation: config?.xAxis?.nameLocation,
          axisLabel: {
            fontSize: `${config?.xAxis?.fontSize}px`,
            rotate: config?.xAxis?.labelRotate,
            margin: config?.xAxis?.margin,
          },
        },
      ],
      yAxis: [
        {
          type: "value",
          position: config?.yAxis?.position,
          name: config?.yAxis?.showName && config?.yAxis?.name,
          nameLocation: config?.yAxis?.nameLocation,
          axisLabel: {
            fontSize: `${config?.yAxis?.fontSize}px`,
            rotate: config?.yAxis?.labelRotate,
            margin: config?.yAxis?.margin,
          },
        },
      ],
      series: [
        ...data.map((element, index) => {
          if (index > 0) {
            const title = element[0];
            const data = element.slice(1, element.length);
            return {
              name: title,
              type: "line",
              stack: "Total",
              areaStyle: {},
              emphasis: {
                focus: "series",
              },
              data: data,
            };
          }
        }),
      ],
    };
    return option;
  };

  const change_col = (cols) => {
    // init_chart();
  };

  const change_config_handler = (newConfig) => {
    // if (!chart) return;
    // chart.setOption(get_options());
  };

  const transformData = async (newData) => {
    let result = Array();
    // result.push([...Object.keys(newData[0])]);
    // newData.forEach((element) => {
    //   result.push([...Object.values(element)]);
    // });
    return result;
  };

  const resizeHandler = () => {
    // chart?.resize({
    //   width: width,
    //   height: height,
    // });
  };
</script>
