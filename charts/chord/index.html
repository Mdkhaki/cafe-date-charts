<style>
  body,
  html {
    overflow: hidden;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .chart-wrapper {
    display: inline-block;
    margin: 0 auto;
  }
</style>

<div id="chart-wrapper" class="chart-wrapper"></div>

<!-- <script src="https://d3js.org/d3.v7.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>

<script src="https://cafedata.io/charts/js/base-cafedata/v1.0.0.js"></script>

<script>
  let option;
  let chartDom;
  let chart;

  // chart specific variables
  let radius;

  // TODO : set develop to false
  let develop = true;
  if (develop) {
    window.onload = () => {
      base_first_time({
        _col_rel: {
          labels: "category",
          values: "Mon",
        },
        _config: {
          chart: {
            ringWidth: "20",
            innerRadius: 200,
            outterRadius: 220,
          },
        },
        // _data: data,
      });
      d3.csv("./data.csv", (newData) => {
        console.log(newData);
      });
    };
  }

  const init_handler = async () => {
    console.log("init_handler called");

    outerRadius = Math.min(width, height) * 0.5;
    innerRadius = outerRadius - 124;

    chord = d3
      .chord()
      .padAngle(0.02)
      .sortSubgroups(d3.descending)
      .sortChords(d3.descending);

    arc = d3
      .arc()
      .innerRadius(innerRadius + 5)
      .outerRadius(innerRadius + 20);

    ribbon = d3.ribbon().radius(innerRadius);

    color = d3.scaleOrdinal(d3.schemeCategory10);

    const svg = d3
      .select("#chart-wrapper")
      .append("svg")
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("font-size", 12)
      .attr("font-family", "sans-serif")
      .style("width", width > height ? "auto" : width)
      .style("height", width <= height ? "auto" : height);

    const chords = chord(data.matrix);

    const group = svg.append("g").selectAll("g").data(chords.groups).join("g");

    function onMouseOver(selected) {
      group.filter((d) => d.index !== selected.index).style("opacity", 0.3);

      svg
        .selectAll(".chord")
        .filter((d) => d.source.index !== selected.index)
        .style("opacity", 0.3);
    }

    function onMouseOut() {
      group.style("opacity", 1);
      svg.selectAll(".chord").style("opacity", 1);
    }

    group
      .append("path")
      .attr("fill", (d) => color(d.index))
      // .attr("stroke", (d) => d3.rgb(color(d.index)).darker())
      .attr("d", arc)

      .on("mouseover", onMouseOver)
      .on("mouseout", onMouseOut);

    group
      .append("text")
      .each((d) => {
        d.angle = (d.startAngle + d.endAngle) / 2;
      })
      .attr("dy", ".35em")
      .attr(
        "transform",
        (d) => `
        rotate(${(d.angle * 180) / Math.PI - 90})
        translate(${innerRadius + 26})
        ${d.angle > Math.PI ? "rotate(180)" : ""}
      `
      )
      .attr("text-anchor", (d) => (d.angle > Math.PI ? "end" : null))
      .text((d) => data.nameByIndex.get(d.index));

    svg
      .append("g")
      .attr("fill-opacity", 0.67)
      .selectAll("path")
      .data(chords)
      .join("path")
      .attr("class", "chord")
      // .attr("stroke", (d) => d3.rgb(color(d.source.index)).darker())
      .attr("fill", (d) => color(d.source.index))
      .attr("d", ribbon)
      .on("mouseover", (d) => onMouseOver(d.source))
      .on("mouseout", (d) => onMouseOut(d.source));

    return svg.node();
  };

  const change_col = (cols) => {
    // init_chart();
  };

  const change_config_handler = (newConfig) => {
    // if (!chart) return;
    // chart.setOption(get_options());
  };

  setTimeout(() => {
    console.log("setTimeout : change_config_handler called...");
  }, 2000);

  const transformData = async (newData) => {
    const imports = await d3.json(
      "https://gist.githubusercontent.com/mbostock/1044242/raw/3ebc0fde3887e288b4a9979dad446eb434c54d08/flare.json"
    );

    console.log(imports);

    const indexByName = new Map();
    const nameByIndex = new Map();
    const matrix = [];
    let n = 0;

    // Returns the Flare package name for the given class name.
    function name(name) {
      return name.substring(0, name.lastIndexOf(".")).substring(6);
    }

    // Compute a unique index for each package name.
    imports.forEach((d) => {
      if (!indexByName.has((d = name(d.name)))) {
        nameByIndex.set(n, d);
        indexByName.set(d, n++);
      }
    });

    // Construct a square matrix counting package imports.
    imports.forEach((d) => {
      const source = indexByName.get(name(d.name));
      let row = matrix[source];
      if (!row) row = matrix[source] = Array.from({ length: n }).fill(0);
      d.imports.forEach((d) => row[indexByName.get(name(d))]++);
    });

    console.log(nameByIndex);

    return {
      matrix,
      indexByName,
      nameByIndex,
    };
  };

  const resizeHandler = () => {
    // chart?.resize({
    //   width: width,
    //   height: height,
    // });
  };

  ////////////////// Events //////////////////

  // function onMouseOver(selected) {
  //   group.filter((d) => d.index !== selected.index).style("opacity", 0.3);

  //   svg
  //     .selectAll(".chord")
  //     .filter((d) => d.source.index !== selected.index)
  //     .style("opacity", 0.3);
  // }

  // function onMouseOut() {
  //   group.style("opacity", 1);
  //   svg.selectAll(".chord").style("opacity", 1);
  // }
</script>
